# src/client/solana_client.py
import asyncio
import base64
import base58
import os
from pathlib import Path
import json
from typing import Dict, List, Optional, Any
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Confirmed
from solders.transaction import Transaction
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from anchorpy import Program, Provider, Wallet, Context, Idl


class SolanaClient:
    """
    Client for interacting with Solana AMMs (Raydium, Orca, etc.)
    """
    
    def __init__(self, rpc_url: str, wallet_private_key: str, program_id: str):
        self.rpc_url = rpc_url
        self.wallet = self._load_wallet(wallet_private_key)
        self.program_id = Pubkey.from_string(program_id)
        self.client = None
        self.program = None
        self.provider = None
        
    async def initialize(self):
        """Initialize the Solana client connection"""
        self.client = AsyncClient(self.rpc_url)
        self.provider = Provider(self.client, Wallet(self.wallet))
        
        idl = await self._load_idl()
        
        if idl:
            self.program = Program(idl, self.program_id, self.provider)
            print(f"âœ… Solana client initialized with program: {self.program_id}")
        else:
            print("âŒ Failed to load IDL")
    
    def _load_wallet(self, private_key_str: str) -> Keypair:
        """Load wallet from private key string directly from config"""
        try:
            if not private_key_str or private_key_str == "3SbpjTnpowgFhvgZwpTeqKK86DdbJRdvQTYk5LBtZxjY":
                # Generate a new wallet for testing
                new_wallet = Keypair()
                private_key_base58 = base58.b58encode(bytes(new_wallet)).decode('utf-8')
                print(f"ðŸ“ Generated new wallet: {new_wallet.pubkey()}")
                print(f"ðŸ”‘ Private key (save this in config): {private_key_base58}")
                return new_wallet
            
            # Handle base58 encoded private key (most common)
            try:
                key_bytes = base58.b58decode(private_key_str)
                if len(key_bytes) == 64:  # Standard keypair length
                    return Keypair.from_bytes(key_bytes)
                else:
                    raise ValueError(f"Invalid key length: {len(key_bytes)}")
                    
            except Exception as e:
                print(f"âŒ Failed to decode base58 private key: {e}")
                raise
                
        except Exception as e:
            print(f"âŒ Failed to load wallet: {e}")
            # Generate a new wallet for testing
            new_wallet = Keypair()
            print(f"ðŸ“ Generated new wallet: {new_wallet.pubkey()}")
            return new_wallet
    
    async def _load_idl(self) -> Optional[Idl]:
        """Load the IDL file generated by Anchor - dynamically find the correct file"""
        try:
            idl_dir = Path(__file__).parent.parent.parent / "anchor" / "target" / "idl"
            
            if not idl_dir.exists():
                print(f"âŒ IDL directory not found: {idl_dir}")
                return None
            
            # List all JSON files in the IDL directory
            idl_files = list(idl_dir.glob("*.json"))
            
            if not idl_files:
                print(f"âŒ No IDL files found in: {idl_dir}")
                return None
            
            # Use the first IDL file found (there should only be one)
            idl_path = idl_files[0]
            print(f"ðŸ“ Found IDL file: {idl_path.name}")
            
            with open(idl_path, 'r') as f:
                idl_json = json.load(f)
            
            return Idl.from_json(idl_json)
            
        except Exception as e:
            print(f"âŒ Error loading IDL: {e}")
            return None
    
    async def get_balance(self) -> float:
        """Get the wallet balance in SOL"""
        try:
            balance = await self.client.get_balance(self.wallet.pubkey())
            return balance.value / 1_000_000_000  # Convert lamports to SOL
        except Exception as e:
            print(f"Error getting balance: {e}")
            return 0.0
   
    async def airdrop_sol(self, amount: float = 1.0):
        """Request airdrop on localnet"""
        try:
            lamports = int(amount * 1_000_000_000)
            signature = await self.client.request_airdrop(self.wallet.pubkey(), lamports)
            
            # Confirm transaction
            await self.client.confirm_transaction(signature.value)
            print(f"âœ… Airdrop successful: {amount} SOL")
        except Exception as e:
            print(f"âŒ Airdrop failed: {e}")
    
    async def initialize_arbitrage_account(self):
        """Initialize the arbitrage account on-chain"""
        if not self.program:
            print("âŒ Program not initialized")
            return None
            
        try:
            # Generate a PDA (Program Derived Address) for the arbitrage account
            arbitrage_account = Keypair()
            
            # Call the initialize function
            tx = await self.program.rpc["initialize"](
                {
                    "accounts": {
                        "arbitrage_account": arbitrage_account.pubkey(),
                        "user": self.wallet.pubkey(),
                        "system_program": Pubkey.from_string("11111111111111111111111111111111"),
                    },
                    "signers": [arbitrage_account, self.wallet],
                }
            )
            
            print(f"âœ… Arbitrage account initialized: {arbitrage_account.pubkey()}")
            print(f"ðŸ“ Transaction: {tx}")
            
            return arbitrage_account.pubkey()
            
        except Exception as e:
            print(f"âŒ Failed to initialize arbitrage account: {e}")
            return None
    
    async def ping_contract(self, arbitrage_account_pubkey: Pubkey):
        """Send a ping to the contract to test connectivity"""
        if not self.program:
            print("âŒ Program not initialized")
            return False
            
        try:
            tx = await self.program.rpc["ping"](
                {
                    "accounts": {
                        "arbitrage_account": arbitrage_account_pubkey,
                        "user": self.wallet.pubkey(),
                    },
                    "signers": [self.wallet],
                }
            )
            
            print(f"âœ… Ping successful: {tx}")
            return True
            
        except Exception as e:
            print(f"âŒ Ping failed: {e}")
            return False

    async def check_arbitrage_opportunity(self):
        """Check for arbitrage opportunities (mock implementation)"""
        if not self.program:
            print("âŒ Program not initialized")
            return None
            
        try:
            # This would call your check_price_difference function
            # For now, we'll use the ping function to test
            result = await self.program.rpc["check_arbitrage"](
                {
                    "accounts": {
                        "arbitrage_account": self.wallet.pubkey(),  # Using wallet as placeholder
                        "user": self.wallet.pubkey(),
                    },
                    "signers": [self.wallet],
                }
            )
            
            return result
            
        except Exception as e:
            print(f"âŒ Arbitrage check failed: {e}")
            return None
        
    async def get_amm_price(self, amm_address: str, token_a: str, token_b: str) -> float:
        """
        Get current price from an AMM pool
        """
        try:
            # This would query the AMM pool account to get reserves and calculate price
            # For Raydium, you'd fetch the pool state account
            pool_pubkey = Pubkey.from_string(amm_address)
            
            # Fetch pool data
            pool_data = await self.client.get_account_info(pool_pubkey)
            if not pool_data.value:
                raise Exception(f"Pool not found: {amm_address}")
            
            # Parse pool data to extract reserves and calculate price
            # This is simplified - actual implementation depends on the AMM
            price = await self._calculate_pool_price(pool_data.value.data, token_a, token_b)
            return price
            
        except Exception as e:
            print(f"Error getting AMM price: {e}")
            return 0.0
    
    async def _calculate_pool_price(self, pool_data: bytes, token_a: str, token_b: str) -> float:
        """
        Calculate price from pool data
        This is AMM-specific and would need to be implemented for each DEX
        """
        # Simplified implementation - you'd need to parse the actual pool structure
        # For a constant product pool: price = reserve_b / reserve_a
        try:
            # Mock implementation - replace with actual AMM data parsing
            reserve_a = 1000000  # Would extract from pool_data
            reserve_b = 50000    # Would extract from pool_data
            
            if reserve_a == 0:
                return 0.0
                
            return reserve_b / reserve_a
        except Exception as e:
            print(f"Error calculating pool price: {e}")
            return 0.0
    
    async def execute_arbitrage(
        self, 
        amm_a: str, 
        amm_b: str, 
        token_a: str, 
        token_b: str, 
        amount: float
    ) -> bool:
        """
        Execute arbitrage trade between two AMMs
        """
        try:
            # 1. Check if arbitrage is still profitable
            price_a = await self.get_amm_price(amm_a, token_a, token_b)
            price_b = await self.get_amm_price(amm_b, token_a, token_b)
            
            if not self._is_arbitrage_profitable(price_a, price_b, amount):
                print("Arbitrage no longer profitable")
                return False
            
            # 2. Prepare transaction
            transaction = Transaction()
            
            # 3. Add swap instructions for both AMMs
            # This would use the Anchor program or direct CPI calls
            
            # 4. Send transaction
            signature = await self.provider.send(transaction)
            
            # 5. Confirm transaction
            await self.client.confirm_transaction(signature)
            
            print(f"Arbitrage executed successfully: {signature}")
            return True
            
        except Exception as e:
            print(f"Arbitrage execution failed: {e}")
            return False
    
    def _is_arbitrage_profitable(self, price_a: float, price_b: float, amount: float) -> bool:
        """
        Determine if arbitrage is profitable after fees
        """
        price_diff = abs(price_a - price_b)
        min_price_diff = 0.01  # 1% minimum difference after fees
        return price_diff / min(price_a, price_b) > min_price_diff
    
    async def close(self):
        """Close the Solana client connection"""
        if self.client:
            await self.client.close()